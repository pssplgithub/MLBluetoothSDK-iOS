#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
#ifndef MLBLUETOOTH_SWIFT_H
#define MLBLUETOOTH_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="MLBluetooth",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class NSDate;

/// The lock was relocked.
SWIFT_CLASS("_TtC11MLBluetooth22AutomaticRelockPrimary")
@interface AutomaticRelockPrimary : NSObject
///
@property (nonatomic, copy) NSDate * _Nullable time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The lock was relocked.
SWIFT_CLASS("_TtC11MLBluetooth24AutomaticRelockSecondary")
@interface AutomaticRelockSecondary : NSObject
///
@property (nonatomic, copy) NSDate * _Nullable time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


///
SWIFT_CLASS("_TtC11MLBluetooth26BluetoothWakeButtonPressed")
@interface BluetoothWakeButtonPressed : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The lock was closed.
SWIFT_CLASS("_TtC11MLBluetooth13ClosedPrimary")
@interface ClosedPrimary : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The lock was closed.
SWIFT_CLASS("_TtC11MLBluetooth15ClosedSecondary")
@interface ClosedSecondary : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A configurable temporary passcode reset was completed.
SWIFT_CLASS("_TtC11MLBluetooth38ConfigurableTempPasscodeResetCompleted")
@interface ConfigurableTempPasscodeResetCompleted : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A configurable temporary passcode reset was initiated.
SWIFT_CLASS("_TtC11MLBluetooth38ConfigurableTempPasscodeResetInitiated")
@interface ConfigurableTempPasscodeResetInitiated : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Demo mode was disabled. Some devices ship with Demo Mode enabled. It will automatically be disabled the first time it communicates with a phone via Bluetooth.
SWIFT_CLASS("_TtC11MLBluetooth16DemoModeDisabled")
@interface DemoModeDisabled : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Demo mode was enabled. Some devices ship with Demo Mode enabled. It will automatically be disabled the first time it communicates with a phone via Bluetooth.
SWIFT_CLASS("_TtC11MLBluetooth15DemoModeEnabled")
@interface DemoModeEnabled : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A firmware update was completed.
SWIFT_CLASS("_TtC11MLBluetooth23FirmwareUpdateCompleted")
@interface FirmwareUpdateCompleted : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
///
@property (nonatomic) NSInteger firmwareVersion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A firmware update was initiated.
SWIFT_CLASS("_TtC11MLBluetooth23FirmwareUpdateInitiated")
@interface FirmwareUpdateInitiated : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
///
@property (nonatomic) NSInteger firmwareVersion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum MLInvalidPasscodeType : uint8_t;

/// An invalid passcode was entered. Check the <code>type</code> field for more details.
SWIFT_CLASS("_TtC11MLBluetooth15InvalidPasscode")
@interface InvalidPasscode : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) enum MLInvalidPasscodeType type;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum MLInvalidWirelessAccessAttemptType : uint8_t;
@class NSNumber;

/// An invalid wireless access attempt occurred. Check the <code>type</code> field for more details.
SWIFT_CLASS("_TtC11MLBluetooth28InvalidWirelessAccessAttempt")
@interface InvalidWirelessAccessAttempt : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) enum MLInvalidWirelessAccessAttemptType type;
///
@property (nonatomic, readonly, strong) NSNumber * _Nullable _userId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


///
SWIFT_CLASS("_TtC11MLBluetooth12KeypadLocked")
@interface KeypadLocked : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The device was locked out after a number of invalid passcode attempts were performed.
SWIFT_CLASS("_TtC11MLBluetooth7LockOut")
@interface LockOut : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A lock reset was completed.
SWIFT_CLASS("_TtC11MLBluetooth18LockResetCompleted")
@interface LockResetCompleted : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A lock reset was initiated.
SWIFT_CLASS("_TtC11MLBluetooth18LockResetInitiated")
@interface LockResetInitiated : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum Visibility : NSInteger;
@class Mechanism;

///
SWIFT_CLASS("_TtC11MLBluetooth9LockState")
@interface LockState : NSObject
///
@property (nonatomic, readonly) enum Visibility visibility;
///
@property (nonatomic, readonly) BOOL keypadActive;
///
@property (nonatomic, readonly) BOOL isJammed;
///
@property (nonatomic, readonly) BOOL isTampered;
///
@property (nonatomic, readonly, strong) Mechanism * _Nonnull primaryMechanism;
///
@property (nonatomic, readonly, strong) Mechanism * _Nonnull secondaryMechanism;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, LoggerConfiguration, open) {
  LoggerConfigurationProduction = 0,
  LoggerConfigurationDebugging = 1,
};

enum MLAuditTrailEventId : uint8_t;

/// This object represents and audit event. Each event has an index and data that is represented by the enumeration <code>MLAuditData</code>. Switch off the data parameter to retrieve the event specific data.
/// For Swift implementations, switch on the <code>data</code> variable to get type safe audit trail data.
/// For Objective-C implementations, switch on the <code>type</code> variable to determine the type. Then cast the <code>object</code> variable as the appropriate type.
SWIFT_CLASS("_TtC11MLBluetooth12MLAuditEntry")
@interface MLAuditEntry : NSObject
/// The index of the audit event.
@property (nonatomic, readonly) NSInteger index;
/// The firmware counter associated with this audit event.
@property (nonatomic, readonly) NSInteger firmwareCounter;
/// For Objective-C implementations, this is an enumeration representing the event type to appropriately cast <code>MLAuditEntry.object</code>.
@property (nonatomic, readonly) enum MLAuditTrailEventId type;
/// For Objective-C implementations, cast <code>object</code> as the appropriate type as specified in <code>MLAuditEntry.type</code>.
@property (nonatomic, readonly, strong) NSObject * _Nonnull object;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// For apps written in Objective-C, this enumeration specifies the audit event type. The associated data can be cast to an object of the same case name.
typedef SWIFT_ENUM(uint8_t, MLAuditTrailEventId, open) {
///
  MLAuditTrailEventIdUnknown = 0x00,
/// See <code>FirmwareUpdateInitiated</code>
  MLAuditTrailEventIdFirmwareUpdateInitiated = 0x01,
/// See <code>FirmwareUpdateCompleted</code>
  MLAuditTrailEventIdFirmwareUpdateCompleted = 0x02,
/// See <code>TimeStopped</code>
  MLAuditTrailEventIdTimeStopped = 0x03,
/// See <code>TimeWritten</code>
  MLAuditTrailEventIdTimeWritten = 0x04,
/// See <code>InvalidWirelessAccessAttempt</code>
  MLAuditTrailEventIdInvalidWirelessAccessAttempt = 0x05,
/// See <code>InvalidPasscode</code>
  MLAuditTrailEventIdInvalidPasscode = 0x06,
/// See <code>WirelessUnlockPrimary</code>
  MLAuditTrailEventIdWirelessUnlockPrimary = 0x07,
/// See <code>PasscodeUnlockPrimary</code>
  MLAuditTrailEventIdPasscodeUnlockPrimary = 0x08,
/// See <code>OpenedPrimary</code>
  MLAuditTrailEventIdOpenedPrimary = 0x09,
/// See <code>ClosedPrimary</code>
  MLAuditTrailEventIdClosedPrimary = 0x0A,
/// See <code>AutomaticRelockPrimary</code>
  MLAuditTrailEventIdAutomaticRelockPrimary = 0x0B,
/// See <code>WirelessUnlockSecondary</code>
  MLAuditTrailEventIdWirelessUnlockSecondary = 0x0C,
/// See <code>PasscodeUnlockSecondary</code>
  MLAuditTrailEventIdPasscodeUnlockSecondary = 0x0D,
/// See <code>OpenedSecondary</code>
  MLAuditTrailEventIdOpenedSecondary = 0x0E,
/// See <code>ClosedSecondary</code>
  MLAuditTrailEventIdClosedSecondary = 0x0F,
/// See <code>AutomaticRelockSecondary</code>
  MLAuditTrailEventIdAutomaticRelockSecondary = 0x10,
/// See <code>DemoModeEnabled</code>
  MLAuditTrailEventIdDemoModeEnabled = 0x11,
/// See <code>DemoModeDisabled</code>
  MLAuditTrailEventIdDemoModeDisabled = 0x12,
/// See <code>LockOut</code>
  MLAuditTrailEventIdLockout = 0x13,
/// See <code>WirelessLockPrimary</code>
  MLAuditTrailEventIdWirelessLockPrimary = 0x14,
/// See <code>KeypadLocked</code>
  MLAuditTrailEventIdKeypadLocked = 0x15,
/// See <code>ThumbturnLocked</code>
  MLAuditTrailEventIdThumbturnLocked = 0x16,
/// See <code>ThumbturnUnlocked</code>
  MLAuditTrailEventIdThumbturnUnlocked = 0x17,
/// See <code>TamperSensorActivated</code>
  MLAuditTrailEventIdTamperSensorActivated = 0x18,
/// See <code>TamperSensorCleared</code>
  MLAuditTrailEventIdTamperSensorCleared = 0x19,
/// See <code>BluetoothWakeButtonPressed</code>
  MLAuditTrailEventIdBluetoothWakeButtonPressed = 0x1A,
/// See <code>TemperatureStatus</code>
  MLAuditTrailEventIdTemperatureStatus = 0x1B,
/// See <code>LockResetInitiated</code>
  MLAuditTrailEventIdLockResetInitiated = 0x1C,
/// See <code>ConfigurableTempPasscodeResetInitiated</code>
  MLAuditTrailEventIdConfigurableTempPasscodeResetInitiated = 0x1D,
/// See <code>LockResetCompleted</code>
  MLAuditTrailEventIdLockResetCompleted = 0x1E,
/// See <code>ConfigurableTempPasscodeResetCompleted</code>
  MLAuditTrailEventIdConfigurableTempPasscodeResetCompleted = 0x1F,
};


/// A class representing an <code>MLProduct</code>’s battery level.
SWIFT_CLASS("_TtC11MLBluetooth14MLBatteryLevel")
@interface MLBatteryLevel : NSObject
/// The time when the battery measurement was performed.
@property (nonatomic, copy) NSDate * _Nonnull time;
/// An array of battery levels.
/// When the battery has sufficent power, the result will be 100.
/// If the battery is low, the result will be 0.
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull batteryLevels;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSString;
@protocol MLLockScannerDelegate;

/// The static instance of <code>MLBluetoothSDK</code> shall be configured with a license and an <code>MLLockScannerDelegate</code>.
SWIFT_CLASS("_TtC11MLBluetooth14MLBluetoothSDK")
@interface MLBluetoothSDK : NSObject
/// The default instance of the Master Lock Bluetooth Scanner.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) MLBluetoothSDK * _Nonnull main;)
+ (MLBluetoothSDK * _Nonnull)main SWIFT_WARN_UNUSED_RESULT;
+ (void)setMain:(MLBluetoothSDK * _Nonnull)value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Configure the Master Lock Bluetooth SDK.
/// \param license The license file provided by The Master Lock Company granting permission to use the SDK.
///
/// \param delegate An instance of <code>MLLockScannerDelegate</code>.
///
/// \param backgroundLocation Allow location scanning when app is in the background. NOTE: If set to true, you must also enable “Location updates” Background mode in Signing & Capabilities.
///
/// \param loggerConfiguration An enumeration of SDK logging levels.
///
///
/// returns:
/// A boolean indicating if the configuration was successful.
- (BOOL)configureWithLicense:(NSString * _Nonnull)license delegate:(id <MLLockScannerDelegate> _Nonnull)delegate backgroundLocation:(BOOL)backgroundLocation loggerConfiguration:(enum LoggerConfiguration)loggerConfiguration SWIFT_WARN_UNUSED_RESULT;
/// Start scanning for Master Lock Bluetooth devices. This should only be called after when <code>MLBluetoothState</code> is <code>.poweredOn</code>. See <code>MLLockScannerDelegate/bluetoothModuleDidUpdate(state:)</code> and <code>MLBluetoothState/poweredOn</code>
///
/// returns:
/// A boolean indicating if the SDK has started scanning.
- (BOOL)startScanning SWIFT_WARN_UNUSED_RESULT;
/// Stop scanning for Master Lock Bluetooth devices.
- (void)stopScanning;
- (CBManagerState)getScannerState SWIFT_WARN_UNUSED_RESULT;
/// Set the delegate for the Bluetooth lock scanner.
/// \param delegate An class that implements the MLLockScannerDelegate protocol.
///
- (void)setLockScannerDelegateWithDelegate:(id <MLLockScannerDelegate> _Nonnull)delegate;
@end

/// An enumeration representing the state of the bluetooth module.
typedef SWIFT_ENUM(NSInteger, MLBluetoothState, open) {
///
  MLBluetoothStatePoweredOff = 0,
///
  MLBluetoothStatePoweredOn = 1,
///
  MLBluetoothStateResetting = 2,
///
  MLBluetoothStateUnauthorized = 3,
///
  MLBluetoothStateUnknown = 4,
///
  MLBluetoothStateUnsupported = 5,
};

/// A state derived from the locks advertisement activity.
typedef SWIFT_ENUM(NSInteger, MLBroadcastState, open) {
/// The lock is broadcasting.
  MLBroadcastStateAwake = 0,
/// The lock is not broadcasting.
  MLBroadcastStateAsleep = 1,
/// The lock is in firmware update mode. A firmware update must be applied before it returns to normal operation. See <code>MLProduct.beginFirmwareUpdate()</code>
  MLBroadcastStateFirmwareUpdate = 2,
};

/// An enumeration specifying the lock’s behavior upon disconnect.
typedef SWIFT_ENUM(NSInteger, MLDisconnectOptions, open) {
/// Perform no action upon disconnect.
  MLDisconnectOptionsNone = 0,
/// Prevent advertising upon disconnect.
  MLDisconnectOptionsPreventAdvertising = 1,
/// Clear keypad activity upon disconnect.
  MLDisconnectOptionsClearKeypadActivity = 2,
};

enum UpdateState : NSInteger;

/// A class representing the state of an <code>MLProduct</code> during the firmware update process.
/// If <code>updateState</code> is <code>.applying</code>, view the <code>percentage</code> variable on this class.
SWIFT_CLASS("_TtC11MLBluetooth21MLFirmwareUpdateState")
@interface MLFirmwareUpdateState : NSObject
/// The state of the firmware update.
@property (nonatomic) enum UpdateState updateState;
/// The percente complete when in <code>UpdateState.applying</code> state.
@property (nonatomic) NSInteger percentage;
/// An error populated if <code>UpdateState</code> is <code>.error</code>.
@property (nonatomic) NSError * _Nullable error;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, UpdateState, open) {
/// Downloading update
  UpdateStateDownloading = 0,
/// Download complete
  UpdateStateDownloadComplete = 1,
/// Applying update to lock. Check percentage in <code>MLFirmwareUpdateState</code>.
  UpdateStateApplying = 2,
/// Validating firmware update with the Connected Products Web API.
  UpdateStateValidating = 3,
/// Update is complete. Lock will transition back to normal operation mode.
  UpdateStateDone = 4,
/// An error has occurred during the update. Restart the update.
  UpdateStateError = 5,
};

///
typedef SWIFT_ENUM(uint8_t, MLInvalidPasscodeType, open) {
///
  MLInvalidPasscodeTypeMasterOrPrimaryOrSecondary = 0x00,
///
  MLInvalidPasscodeTypeTemporary = 0x01,
///
  MLInvalidPasscodeTypeIndeterminate = 0x02,
};

/// An enumeration representing the reason the lock rejected a wireless access attempt.
typedef SWIFT_ENUM(uint8_t, MLInvalidWirelessAccessAttemptType, open) {
///
  MLInvalidWirelessAccessAttemptTypeUnauthenticatedUser = 0x00,
///
  MLInvalidWirelessAccessAttemptTypeInvalidSessionTime = 0x01,
///
  MLInvalidWirelessAccessAttemptTypeReplay = 0x02,
///
  MLInvalidWirelessAccessAttemptTypeUnauthenticatedCommand = 0x03,
///
  MLInvalidWirelessAccessAttemptTypeInvalidAuthenticatedCommandTime = 0x04,
///
  MLInvalidWirelessAccessAttemptTypeNotPermitted = 0x05,
///
  MLInvalidWirelessAccessAttemptTypeNotScheduled = 0x06,
};

typedef SWIFT_ENUM(NSInteger, MLLockMechanism, open) {
/// The product’s primary locking mechanism. Some products may have only one.
  MLLockMechanismPrimary = 0,
/// The product’s secondary locking mechanism.
  MLLockMechanismSecondary = 1,
};

@class MLProduct;

/// The delegate of a <code>LockScanner</code> object must adopt the <code>MLLockScannerDelegate</code> protocol.
/// The lock scanner calls the methods of its delegate during the lifecycle of a Master Lock Bluetooth device’s connection to the phone.
SWIFT_PROTOCOL("_TtP11MLBluetooth21MLLockScannerDelegate_")
@protocol MLLockScannerDelegate
/// Tells the delegate that a Master Lock Bluetooth device was discovered.
/// \param deviceId The unique identifier associated with a Master Lock product.
///
- (void)didDiscoverDeviceWith:(NSString * _Nonnull)deviceId;
/// Asks the delegate if the device should be connected to.
/// \param deviceId The unique identifier associated with a Master Lock product.
///
/// \param rssi The signal strength of the broadcasting device.
///
- (BOOL)shouldConnectToDeviceWith:(NSString * _Nonnull)deviceId andRSSI:(NSNumber * _Nonnull)rssi SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for an <code>MLProduct</code> whose device identifer matches the one provided. The <code>MLProduct</code> provides the SDK the commands that had been queued, and it provides the credentials necessary to securely transmit data over the Bluetooth LE connection.
/// \param deviceId The unique identifier associated with a Master Lock product.
///
- (MLProduct * _Nullable)productForDeviceId:(NSString * _Nonnull)deviceId SWIFT_WARN_UNUSED_RESULT;
/// Notifies the delegate of a state change for the bluetooth module.
/// \param state An <code>MLBluetoothState</code> enumeration.
///
- (void)bluetoothModuleDidUpdateWithState:(enum MLBluetoothState)state;
@end

///
typedef SWIFT_ENUM(uint8_t, MLPasscodeType, open) {
///
  MLPasscodeTypeMaster = 0x00,
///
  MLPasscodeTypePrimary = 0x01,
///
  MLPasscodeTypeTemporary = 0x02,
///
  MLPasscodeTypeSecondary = 0x04,
///
  MLPasscodeTypeDemo = 0x08,
///
  MLPasscodeTypeConfigurableTemporary = 0x10,
};

@protocol MLProductDelegate;
enum MLRegion : NSInteger;

/// A class representing a Master Lock Product. The parameters needed to initialize an <code>MLProduct</code> must come from Master Lock’s Connected Products Web API. Commands are added to a First-In-First-Out queue and executed the next time the product and phone connect. An <code>MLProduct</code> should be initialized once and a reference to the object should be held so the underlying framework can access the pending commands.
SWIFT_CLASS("_TtC11MLBluetooth9MLProduct")
@interface MLProduct : NSObject
/// The unique identifier associated with a Master Lock product.
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceId;
/// The actual firmware version, as advertised by the Master Lock Product.
@property (nonatomic, readonly) NSInteger firmwareVersion;
/// The product calls the methods of its delegate to indicate changes to its connection state and Bluetooth events.
@property (nonatomic, weak) id <MLProductDelegate> _Nullable delegate;
/// When updating time, ensure that the time sent to a lock is validated against network server time.
@property (nonatomic) BOOL requiresTrustedTime;
/// The current reachability state.
@property (nonatomic) enum MLBroadcastState reachability;
/// A class representing a Master Lock Product. These parameters must come from Master Lock’s Connected Products Web API.
/// \param deviceId The unique identifier associated with a Master Lock product.
///
/// \param accessProfile A string representing a user’s credentials to an <code>MLProduct</code>.
///
/// \param firmwareVersion The firmware version that is expected on the lock.
///
/// \param region The region of the lock. Default: <code>MLRegion.na</code>
///
///
/// returns:
/// An <code>MLProduct</code>.
- (nonnull instancetype)initWithDeviceId:(NSString * _Nonnull)deviceId accessProfile:(NSString * _Nonnull)accessProfile firmwareVersion:(NSInteger)firmwareVersion region:(enum MLRegion)region OBJC_DESIGNATED_INITIALIZER;
/// Update the accessProfile for the <code>MLProduct</code>. The accessProfile parameter must come from Master Lock’s Connected Products Web API.
/// \param accessProfile A string representing a user’s credentials to an <code>MLProduct</code>.
///
/// \param firmwareVersion The expected firmware version of the MLProduct.
///
- (void)updateWithAccessProfile:(NSString * _Nonnull)accessProfile firmwareVersion:(NSInteger)firmwareVersion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface MLProduct (SWIFT_EXTENSION(MLBluetooth))
/// Update the product to the specified firmware version.
/// \param firmwareVersion The firmware version to update to.
///
- (void)updateFirmwareWithFirmwareVersion:(NSInteger)firmwareVersion;
@end



@interface MLProduct (SWIFT_EXTENSION(MLBluetooth))
- (void)lockResetOnComplete:(void (^ _Nonnull)(void))onComplete onError:(void (^ _Nonnull)(NSError * _Nonnull))onError;
@end




enum MLUnlockOptions : NSInteger;

@interface MLProduct (SWIFT_EXTENSION(MLBluetooth))
/// Queue a read memory command to retrieve the secondary passcode.
/// \param index The index of the secondary passcode to read.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readSecondaryPasscodeAtIndex:(NSInteger)index completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nullable, NSError * _Nullable))completion;
/// Queue a write memory command to write a secondary passcode to the product.
/// \param passcode The passcode to write to the product.
///
/// \param index The zero-based index to store the passcode. (0 - 4)
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)writeSecondaryPasscodeWithPasscode:(NSArray<NSString *> * _Nonnull)passcode atIndex:(NSInteger)index completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a clear secondary passcode command.
/// \param index An index representing the slot of the secondary code to clear.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)clearSecondaryPasscodeWithIndex:(NSInteger)index completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue an unlock command. The product does not perform the unlock until Bluetooth has been disconnected. <em>Clients shall use the disconnect command to trigger this immediately.</em>
/// \param option An enumeration specifying which shackle/door to unlock.
///
/// \param completion A completion block triggered with the response data or an error.
///
- (void)unlockWithOption:(enum MLUnlockOptions)option completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue an unlock command. The product does not perform the unlock until Bluetooth has been disconnected. <em>Clients shall use the disconnect command to trigger this immediately.</em>
/// \param option An enumeration specifying which shackle/door to unlock.
///
/// \param seconds The number of seconds before the lock automatically relocks. [Between 4 and 60]
///
/// \param completion A completion block triggered with the response data or an error.
///
- (void)unlockWithOption:(enum MLUnlockOptions)option seconds:(NSInteger)seconds completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a write memory command to update the product’s automatic relock time.
/// \param relockTime The relock time to write to the product.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)writeRelockTimeWithRelockTime:(NSInteger)relockTime completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a write memory command to write a primary passcode to the product.
/// \param passcode The passcode to write to the product.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)writePrimaryPasscodeWithPasscode:(NSArray<NSString *> * _Nonnull)passcode completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
@end


@interface MLProduct (SWIFT_EXTENSION(MLBluetooth))
/// A method to check if there are pending commands queued by the SDK user.
///
/// returns:
/// A boolean indicating whether the product has pending commands.
@property (nonatomic, readonly) BOOL hasPendingCommands;
@end


SWIFT_AVAILABILITY(watchos,introduced=7.0.0) SWIFT_AVAILABILITY(ios,introduced=13.0.0)
@interface MLProduct (SWIFT_EXTENSION(MLBluetooth))
/// Queue a clear all secondary passcode command.
- (void)clearAllSecondaryPasscodesWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
@end

@class NSData;
enum MLStateOptions : NSInteger;
@class MLState;

@interface MLProduct (SWIFT_EXTENSION(MLBluetooth))
/// Queue a disconnect command.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)disconnectWithCompletion:(void (^ _Nonnull)(void))completion;
/// Queue a disconnect command.
/// \param option An enumeration specifying the lock’s behavior upon disconnect.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)disconnectWithOption:(enum MLDisconnectOptions)option completion:(void (^ _Nonnull)(void))completion;
/// Queue a keep alive command to reset the lock’s protocol timeout timer.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)keepAliveWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a write authenticated memory command. The payload for this command must come from Master Lock’s Connected Products Web API.
/// \code
/// // Convert a base 64 encoded string to a Data object:
/// if let base64Data = Data(base64Encoded: base64EncodedString) {
///        ...
/// }
///
/// \endcode\param payload A base64 encoded string to write to the lock. This must come from Master Lock’s Connected Products Web API.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)writeAuthenticatedMemoryWithPayload:(NSData * _Nonnull)payload completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a read memory command to retrieve the firmware counter.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readFirmwareCounterWithCompletion:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completion;
/// Queue a read memory command to retrieve the public configuration counter.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readPublicConfigurationCounterWithCompletion:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completion;
/// Queue a read memory command to retrieve the primary passcode counter.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readPrimaryPasscodeCounterWithCompletion:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completion;
/// Queue a read memory command to retrieve the secondary passcode counter.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readSecondaryPasscodeCounterWithCompletion:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completion;
/// Queue a read memory command to retrieve the primary passcode.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readPrimaryPasscodeWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nullable, NSError * _Nullable))completion;
/// Queue a read memory command to retrieve the secondary passcode.
/// \param index The index of the secondary passcode to read.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readSecondaryPasscodeAtOneBasedIndex:(NSInteger)index completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nullable, NSError * _Nullable))completion;
/// Queue a read memory command to retrieve the relock time.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readRelockTimeWithCompletion:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completion;
/// Queue a write memory command to write a primary passcode to the product.
/// \param passcode The passcode to write to the product.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)writeWithPrimaryPasscode:(NSString * _Nonnull)passcode completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a write memory command to write a secondary passcode to the product.
/// \param passcode The passcode to write to the product.
///
/// \param index The one-based index to store the passcode. (1 - 5)
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)writeWithSecondaryPasscode:(NSString * _Nonnull)passcode atOneBasedIndex:(NSInteger)index completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a write memory command to update the product’s automatic relock time.
/// \param relockTime The relock time to write to the product.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)writeWithRelockTime:(NSInteger)relockTime completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a read state command.
/// \param option An enumeration specifying which state to query. Some products may only have one state.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readStateWithOption:(enum MLStateOptions)option completion:(void (^ _Nonnull)(MLState * _Nullable, NSError * _Nullable))completion;
/// Queue a read battery command.
/// \param completion A completion triggered once the battery has been retrived from the lock.
///
- (void)readBatteryWithCompletion:(void (^ _Nonnull)(MLBatteryLevel * _Nullable, NSError * _Nullable))completion;
/// Queue an unlock command. This will use the primary lock.
/// \param completion A completion block triggered with the response data or an error.
///
- (void)unlockWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue an unlock command.
/// \param mechanism An enumeration specifying which shackle/door to unlock.
///
/// \param completion A completion block triggered with the response data or an error.
///
- (void)unlockWithMechanism:(enum MLUnlockOptions)mechanism completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue an unlock command.
/// \param mechanism An enumeration specifying which shackle/door to unlock.
///
/// \param seconds The number of seconds before the lock automatically relocks. [Between 4 and 60]
///
/// \param completion A completion block triggered with the response data or an error.
///
- (void)unlockWithMechanism:(enum MLUnlockOptions)mechanism seconds:(NSInteger)seconds completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a clear secondary passcode command.
/// \param index An index representing the slot of the secondary code to clear.
///
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)clearSecondaryPasscodeAtOneBasedIndex:(NSInteger)index completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Queue a clear all secondary passcode command.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)clearAllSecondaryPasscodesWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Read the signal strength of the bluetooth device.
/// \param completion A completion containing the bluetooth signal strength.
///
- (void)readRSSIWithCompletion:(void (^ _Nonnull)(NSNumber * _Nullable, NSError * _Nullable))completion;
/// Queue a relock command for locks that have a manual relocking mechanism.
/// \param completion A completion once the command is performed.
///
- (void)relockWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Sets whether the bolt extends to left or right of the lock. From the inside of the door looking at the thumbturn side of the deadbolt, a leftHanded door means that the deadbolt is on the left and the bolt extends to the left.
/// \param isLeftHanded From the inside of the door looking at the thumbturn side of the deadbolt, a leftHanded door means that the deadbolt is on the left and the bolt extends to the left.
///
/// \param completion A completion once the command is performed.
///
- (void)setDeadboltLeftHanded:(BOOL)isLeftHanded completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Reads whether the bolt extends to left or right of the lock. From the inside of the door looking at the thumbturn side of the deadbolt, a leftHanded door means that the deadbolt is on the left and the bolt extends to the left.
/// \param completion result is true if is Left Handed, false if Right Handed
///
- (void)readIsDeadboltLeftHandedWithCompletion:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completion;
/// For Deadbolt only with minimum firmware version of 1679338484: sets flag to indicate if a door position sensor is enabled.
/// \param isInstalled A boolean indicating if the sensor is installed or not.
///
/// \param completion A completion once the command is performed.
///
- (void)setIsDoorPositionSensorEnabled:(BOOL)isInstalled completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// For Deadbolt only with minimum firmware version of 1679338484: reads flag if door position sensor is enabled.
/// \param completion result is true if sensor is enabled.
///
- (void)readIsDoorPositionSensorEnabledWithCompletion:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completion;
/// Queue a read time command.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readTimeWithCompletion:(void (^ _Nonnull)(NSDate * _Nullable, NSError * _Nullable))completion;
/// Queue a read time command.
/// \param completion A completion triggered after the lock disconnects from the mobile device.
///
- (void)readTimeWithCompletionHandler:(void (^ _Nonnull)(NSDate * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(ios,introduced=13.0.0);
@end


/// The delegate of an <code>MLProduct</code> object must adopt the <code>MLProductDelegate</code> protocol.
/// The product calls the methods of its delegate to indicate changes to its connection state and Bluetooth events.
SWIFT_PROTOCOL("_TtP11MLBluetooth17MLProductDelegate_")
@protocol MLProductDelegate
/// Tells the delegate that a the product’s state has changed.
/// \param product The <code>MLProduct</code> whose state changed.
///
/// \param state The Bluetooth state of the <code>MLProduct</code>
///
- (void)product:(MLProduct * _Nonnull)product didChangeState:(enum MLBroadcastState)state;
/// Tells the delegate that the product is connected.
/// \param product The <code>MLProduct</code> that connected.
///
- (void)didConnectTo:(MLProduct * _Nonnull)product;
/// Tells the delegate that the product is disconnected.
/// \param product The <code>MLProduct</code> that disconnected.
///
- (void)didDisconnectFrom:(MLProduct * _Nonnull)product;
/// Tells the delegate that the product failed to connect.
/// \param product The <code>MLProduct</code> that failed to connect.
///
/// \param error An error indicating the reason for failure.
///
- (void)didFailToConnectTo:(MLProduct * _Nonnull)product error:(NSError * _Nullable)error;
@optional
/// Informs the delegate of state changes during a firmware update for the <code>MLProduct</code>.
/// \param product The <code>MLProduct</code> that is updating.
///
/// \param state An object representing the state of an <code>MLProduct</code> during the firmware update process.
///
- (void)firmwareUpdateDidChangeStateFor:(MLProduct * _Nonnull)product state:(MLFirmwareUpdateState * _Nonnull)state;
@required
/// Informs the delegate that the <code>MLProduct</code>’s firmware version and accessProfile must be updated.
/// \param product The <code>MLProduct</code> that should be updated.
///
- (void)shouldUpdateProductDataWithProduct:(MLProduct * _Nonnull)product;
/// Informs the delegate that audit trail entries were read for the specified <code>MLProduct</code>.
/// \param product The <code>MLProduct</code>.
///
/// \param auditEntries An array of <code>MLAuditEntry</code>s.
///
- (void)product:(MLProduct * _Nonnull)product didRead:(NSArray<MLAuditEntry *> * _Nonnull)auditEntries;
/// Informs the delegate that the state of the lock changed. This could be the visibility or the state of a shackle or door.
/// \param product The <code>MLProduct</code>.
///
/// \param state An object representing the state of the <code>MLProduct</code>.
///
- (void)product:(MLProduct * _Nonnull)product didChange:(LockState * _Nonnull)state;
@end

/// To Comply with GDPR, use <code>MLRegion</code> to specify the region of a Master Lock Smart Lock.
typedef SWIFT_ENUM(NSInteger, MLRegion, open) {
/// North America
  MLRegionNa = 0,
/// Europe
  MLRegionEu = 1,
};


/// A class that represents the state of a <code>MLProduct</code>’s lock.
SWIFT_CLASS("_TtC11MLBluetooth7MLState")
@interface MLState : NSObject
/// A boolean indicating if the keypad was recently pressed.
@property (nonatomic) BOOL isKeypadActive;
/// A boolean indicating if the lock is open.
@property (nonatomic) BOOL isOpen;
/// A boolean indicating if the lock is unlocked.
@property (nonatomic) BOOL isUnlocked;
/// A boolean indicating if the lock is jammed. Not applicable for all lock types.
@property (nonatomic) BOOL isJammed;
/// A boolean indicating if the tamper sensor is triggered. Not applicable for all lock types.
@property (nonatomic) BOOL isTampered;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// An enumeration specifying the product’s locking mechanism.
typedef SWIFT_ENUM(NSInteger, MLStateOptions, open) {
/// The product’s primary locking mechanism. Some products may have only one.
  MLStateOptionsPrimary = 0,
/// The product’s secondary locking mechanism.
  MLStateOptionsSecondary = 1,
};

/// An enumeration specifying the product’s locking mechanism.
typedef SWIFT_ENUM(NSInteger, MLUnlockOptions, open) {
/// The product’s primary locking mechanism. Some products may have only one.
  MLUnlockOptionsPrimary = 0,
/// The product’s secondary locking mechanism.
  MLUnlockOptionsSecondary = 1,
};


///
SWIFT_CLASS("_TtC11MLBluetooth9Mechanism")
@interface Mechanism : NSObject
/// When <code>mechanismState</code> is <code>unlocked</code>, this field holds the amount of time remaining before automatic relock.
@property (nonatomic, readonly) NSInteger countdown;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum MechanismState : NSInteger;

@interface Mechanism (SWIFT_EXTENSION(MLBluetooth))
/// Get the MechanismState. For Objective-C use only. For swift, switch on <code>mechanismState</code>.
- (enum MechanismState)getState SWIFT_WARN_UNUSED_RESULT;
/// Get the number of seconds before the locking mechanism auto relocks.
/// Check this value when <code>getState()</code> is <code>unlocked</code>
/// For Objective-C use only. For swift, switch on <code>mechanismState</code>.
- (NSInteger)getCountdown SWIFT_WARN_UNUSED_RESULT;
@end

/// For Objective-C compatibility only. For swift, switch on <code>mechanismState</code>.
typedef SWIFT_ENUM(NSInteger, MechanismState, open) {
///
  MechanismStateUnknown = 0,
///
  MechanismStateLocked = 1,
///
  MechanismStatePendingUnlock = 2,
/// Only used for locks with an explicit relock command.
  MechanismStatePendingRelock = 3,
///
  MechanismStateUnlocked = 4,
///
  MechanismStateOpen = 5,
///
  MechanismStateOpenLocked = 6,
};



/// The lock was opened.
SWIFT_CLASS("_TtC11MLBluetooth13OpenedPrimary")
@interface OpenedPrimary : NSObject
///
@property (nonatomic, copy) NSDate * _Nullable time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The lock was opened.
SWIFT_CLASS("_TtC11MLBluetooth15OpenedSecondary")
@interface OpenedSecondary : NSObject
///
@property (nonatomic, copy) NSDate * _Nullable time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The lock was unlocked via a passcode. Check the <code>passcode</code> field to determine which code was used.
SWIFT_CLASS("_TtC11MLBluetooth21PasscodeUnlockPrimary")
@interface PasscodeUnlockPrimary : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) enum MLPasscodeType passcode;
///
@property (nonatomic, readonly, strong) NSNumber * _Nullable _counterValue;
///
@property (nonatomic, readonly, strong) NSNumber * _Nullable _unlockTime;
///
@property (nonatomic, readonly, strong) NSNumber * _Nullable _secondaryPasscodeIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The lock was unlocked via a passcode. Check the <code>passcode</code> field to determine which code was used.
SWIFT_CLASS("_TtC11MLBluetooth23PasscodeUnlockSecondary")
@interface PasscodeUnlockSecondary : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) enum MLPasscodeType passcode;
///
@property (nonatomic, readonly, strong) NSNumber * _Nullable _unlockTime;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


///
SWIFT_CLASS("_TtC11MLBluetooth21TamperSensorActivated")
@interface TamperSensorActivated : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


///
SWIFT_CLASS("_TtC11MLBluetooth19TamperSensorCleared")
@interface TamperSensorCleared : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

///
typedef SWIFT_ENUM(uint8_t, TemperatureEvent, open) {
///
  TemperatureEventLow = 0x00,
///
  TemperatureEventNormal = 0x01,
///
  TemperatureEventHigh = 0x02,
};


///
SWIFT_CLASS("_TtC11MLBluetooth17TemperatureStatus")
@interface TemperatureStatus : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) enum TemperatureEvent temperatureEvent;
/// Temperature in degrees C.
@property (nonatomic) NSInteger temperatureDegreesCelcius;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


///
SWIFT_CLASS("_TtC11MLBluetooth15ThumbturnLocked")
@interface ThumbturnLocked : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


///
SWIFT_CLASS("_TtC11MLBluetooth17ThumbturnUnlocked")
@interface ThumbturnUnlocked : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The lock’s internal clock was stopped for an unknown amount of time. This likely occurred due to a critical exception such as power los or hard boot.
SWIFT_CLASS("_TtC11MLBluetooth11TimeStopped")
@interface TimeStopped : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The lock’s time was updated.
SWIFT_CLASS("_TtC11MLBluetooth11TimeWritten")
@interface TimeWritten : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
///
@property (nonatomic, copy) NSDate * _Nonnull newTime;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC11MLBluetooth17UnknownAuditEvent")
@interface UnknownAuditEvent : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

///
typedef SWIFT_ENUM(NSInteger, Visibility, open) {
///
  VisibilityVisible = 0,
///
  VisibilityUnknown = 1,
};


///
SWIFT_CLASS("_TtC11MLBluetooth19WirelessLockPrimary")
@interface WirelessLockPrimary : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A wireless unlock occurred.
SWIFT_CLASS("_TtC11MLBluetooth21WirelessUnlockPrimary")
@interface WirelessUnlockPrimary : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
///
@property (nonatomic, readonly, strong) NSNumber * _Nullable _unlockTime;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A wireless unlock occurred.
SWIFT_CLASS("_TtC11MLBluetooth23WirelessUnlockSecondary")
@interface WirelessUnlockSecondary : NSObject
///
@property (nonatomic, copy) NSDate * _Nonnull time;
///
@property (nonatomic) NSInteger userId;
///
@property (nonatomic, readonly, strong) NSNumber * _Nullable _unlockTime;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
